# 美团后台 #

## 面向对象 ##

	

## tcp 三次握手 ##

	https://blog.csdn.net/qzcsu/article/details/72861891

## volatile ##

	volatile保证了可见性和有序性。
		可见性：当一个共享变量被volatile修饰时，如果一个线程修改了值，它会保证修改的值会立即被更新到主存，
			   当有其他线程需要读取时，它会去内存中读取新值。
		有序性：允许编译器和处理器对指令进行重排序。
			   1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，
				  且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；
			   2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，
				  也不能把volatile变量后面的语句放到其前面执行。

	可以保证原子性吗？
	    对基本数据类型的变量的读取和赋值操作是原子性操作，但对类似自增操作无法保证，但可以使用采用synchronized实现。
			自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：
			假如某个时刻变量inc的值为10，线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；
		    然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对
			变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，
			发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。
	
	volatile修饰的变量如果是对象或数组之类的，其含义是对象获数组的地址具有可见性，但是数组或对象内部的成员改变不具备可见性：
	
	https://www.cnblogs.com/dolphin0520/p/3920373.html