# 阿里巴巴面试题整理

## String、StringBuffer、StringBuilder的区别？对应的使用场景？

	区别：
		1.String：字符串常量，不可改变的对象
			（对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象）
		2.StringBuffer：字符串变量，可改变的对象，线程安全的
		3.StringBuilder：字符串变量，可改变的对象，线程非安全的

	使用场景：
		不需要频繁的拼接字符串的时候使用String，相反需要经常拼接字符串的时候使用
		StringBuilder。StringBuilder与StringBuffer相比，两个类似，不同的是
		StringBuilder是非线程安全的，适合在单线程的情况下使用。多线程情况也可以使用，不过
		需要手动加同步。StrngBuffer是线程安全的，适合在多线程的情况下使用。StringBuilder
		的效率要StringBuffer高
	
	https://blog.csdn.net/loveyaozu/article/details/47037957
	https://segmentfault.com/a/1190000011016459

## HashMap、HashTable、ConcurrentHashMap的区别？

	1.HashTable和HashMap采用相同的存储机制，哈希表（数组+链表）。
	2.HashMap是非线程安全的。HashTable是线程安全的，内部的方法基本都经过synchronized修饰。ConcurrentHashMap
	3.HashMap可以存储null键和null值，HashTable和ConCurrentHashMap中put进的键值只要有一个null，直接抛出NullPointerException。
	4.HashMap默认初始化数组的大小为16，HashTable为11。前者扩容时乘2，后者为乘2加1。
	5.因为同步、哈希性能等原因，性能肯定是HashMap更佳，因此HashTable已被淘汰
	6.ConcurrentHashMap采用分段的数组+链表实现,把整个Map分为N个Segment，在每一个分段上都用lock锁进行保护，相对于HashTable的syn关键字锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。
	
	https://www.cnblogs.com/heyonggang/p/9112731.html
	https://www.cnblogs.com/zx-bob-123/archive/2017/12/26/8118074.html

## mysql的存储引擎有哪几种？

	1.MyISAM：独立于操作系统的；无法处理事务，这就意味着有事务处理需求的表，不能使用MyISAM存储引擎。
	2.InnoDB：事务型存储引擎。提供了事务、行级锁机制和外键约束的功能。
	3.Memory：只存在于内存中。它使用散列索引，所以数据的存取速度非常快。因为是存在于内存中，所以这种类型常应用于临时表中。
	4.Merge：Merge表就是几个相同MyISAM表的聚合器；Merge表中并没有数据，对Merge类型的表可以进行查询、更新、删除操作，这些操作实际上是对内部的MyISAM表进行操作。
	5.archive：这种类型只支持select 和 insert语句，而且不支持索引。常应用于日志记录和聚合分析方面。
	
	https://blog.csdn.net/codepen/article/details/46678725
	https://blog.csdn.net/qi_ruihua/article/details/54892844

## sql优化有哪些着手点？

	https://blog.csdn.net/zly9923218/article/details/51007554
	https://blog.csdn.net/jie_liang/article/details/77340905

## 组合索引的最左前缀原则的含义？

![](https://i.imgur.com/AEo4EFv.jpg)

	https://blog.csdn.net/junzixing1985/article/details/79859378
	https://www.cnblogs.com/jamesbd/p/4333901.html
	https://www.jianshu.com/p/b7911e0394b0

## 浅复制和深复制？怎样实现深复制？

	浅拷贝仅仅复制所考虑的对象，而不复制它所引用的对象；
	深拷贝把要复制的对象所引用的对象都复制了一遍。

	改写从Object类中继承来的clone方法。
	 	// 改为深复制：
        Student3 student = (Student3) super.clone();
        // 本来是浅复制，现在将Teacher对象复制一份并重新set进来
        student.setTeacher((Teacher2) student.getTeacher().clone());
        return student;

## 如何实现不可变的类？

	不可变类只是其实例不能被修改的类，每个实例中包含的所有信息都必须在创建该实例的时候就提供，并在对象的整个生命周期内固定不变。

	要创建不可变类，要实现下面几个步骤：

		1.将类声明为final，所以它不能被继承
		2.将所有的成员声明为私有的，这样就不允许直接访问这些成员
		3.对变量不要提供setter方法
		4.将所有可变的成员声明为final，这样只能对它们赋值一次
		5.通过构造器初始化所有成员，进行深拷贝(deep copy)
		6.在getter方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝

	https://blog.csdn.net/ksjay_1943/article/details/53353359
	https://blog.csdn.net/fuzhongmin05/article/details/54880139

## 用到过哪些设计模式？单例模式的实现？

	单例模式、工厂模式、建造(Builder)模式、观察者模式、适配器(Adapter)模式

	一个私有的构造方法加一个私有的静态当前类实例对象和一个公有的静态获取实

## ArrayList和LinkedList的区别,各个基本操作的复杂度是多少，方法是什么，ArrayList的底层结构是什么，如果数组容量不够怎么办，扩容之后get的复杂度是多少

	1.ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 
	2.对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。 
	3.对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。 
		
	ArrayList 是线性表（数组）
		get() 直接读取第几个下标，复杂度 O(1)
		add(E) 添加元素，直接在后面添加，复杂度O（1）
		add(index, E) 添加元素，在第几个元素后面插入，后面的元素需要向后移动，复杂度O（n）
		remove（）删除元素，后面的元素需要逐个移动，复杂度O（n）
	
	LinkedList 是链表的操作
		get() 获取第几个元素，依次遍历，复杂度O(n)
		add(E) 添加到末尾，复杂度O(1)
		add(index, E) 添加第几个元素后，需要先查找到第几个元素，直接指针指向操作，复杂度O(n)
		remove（）删除元素，直接指针指向操作，复杂度O(1)
	https://blog.csdn.net/u011240877/article/details/52853989
	时间复杂度：https://www.jianshu.com/p/f4cca5ce055a

## 数据挖掘十大算法

	C4.5、K-Means、支持向量机、最大期望(EM)、PageRank、AdaBoost、K最近邻、Apriori
	Naive Bayes、cart

## 决策树的C4.5算法以及其核心ID3算法



## svm

## kmeans