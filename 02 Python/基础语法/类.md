# 类

[TOC]

类提供了一种组合数据和功能的方法。 

**创建一个新类意味着创建一个`新的对象`类型**，从而允许创建一个该类型的新实例。

每个类的实例可以拥有保存自己状态的属性，也可以有改变自己状态的（定义在类中的）方法。

- 类继承机制允许多个基类。
- 派生类可以覆盖它基类的任何方法。
- 一个方法可以调用基类中相同名称的的方法。
- 对象可以包含任意数量和类型的数据。
- 类在运行时创建，可以在创建后修改。
- 没有 从其方法中引用的对象成员的简写：方法函数声明时，使用一个表示对象的显式第一个参数，该参数由调用隐式提供。
- 类本身也是对象。
- 内置类型可以用作用户扩展的基类。
- 大多数具有特殊语法（算术运算符，下标等）的内置运算符都可以为类实例而重新定义。

## 1、名称和对象

对象具有 individuality，**多个名称（在多个作用域内）可以绑定到同一个对象**，这在其他语言中称为别名。

在处理不可变的基本类型（数字，字符串，元组）时可以安全地忽略它。

**涉及可变对象，如列表，字典和大多数其他类型的 Python 代码的语义可能会产生惊人的影响**。因为别名在某些方面表现得像指针。 例如，因为在实现中，只传递了一个指针，所以传递一个对象的代价很小，如果函数修改了作为参数传递的对象，调用者将看到这个更改 --- 这就不需要像 Pascal 中那样使用两个不同的参数传递机制。


## 2、初探类

类引入了一些新语法，三种新对象类型和一些新语义。

### 2.1、类定义语法

最简单的类定义看起来像这样:

```python
class ClassName:
    <statement-1>
    .
    .
    .
    <statement-N>
```

类定义与函数定义 (def 语句) 一样**必须被执行才会起作用**。（你可以尝试将类定义放在 if 语句的一个分支或是函数的内部。）

在实践中，类定义内的语句通常都是函数定义，但也允许有其他语句，有时还很有用。 

在类内部的函数定义通常具有一种特别形式的参数列表，这是方法调用的约定规范所指明的。

**当进入类定义时，将创建一个新的命名空间，并将其用作局部作用域**。因此，所有对局部变量的赋值都是在这个新命名空间之内。 特别的，函数定义会绑定到这里的新函数名称。

当（从结尾处）正常离开类定义时，将创建一个 类对象。这基本上是一个类定义所创建的命名空间的封装。

原始的（在进入类定义之前起作用的）局部作用域将重新生效，类对象将在这里被绑定到类定义头所给出的类名称 (在这个示例中为 ClassName)。

### 2.2、类对象

类对象支持两种操作：属性引用和实例化。

(1)属性引用 

使用 Python 中所有属性引用所使用的标准语法: obj.name。 

**有效的属性名称是，类对象被创建时，存在于类命名空间中的所有名称**。 因此，如果类定义是这样的:

```python
class MyClass:
    """A simple example class"""
    i = 12345

    def f(self):
        return 'hello world'
```

那么 `MyClass.i` 和 `MyClass.f` 就是有效的属性引用，将分别返回一个整数和一个函数对象。

类属性也可以被赋值，因此可以通过赋值来更改 `MyClass.i` 的值。 

`__doc__`也是一个有效的属性，将返回所属类的文档字符串: "A simple example class"。

(2)实例化

类的 实例化 使用函数表示法。 

可以把类对象视为是返回该类的一个新实例的不带参数的函数。 举例来说（假设使用上述的类）:

```python
x = MyClass()
```

创建类的新 实例 并将此对象分配给局部变量 x。

实例化操作（“调用”类对象）会创建一个空对象。 许多类喜欢**创建带有特定初始状态的自定义实例**。 为此类定义可能包含一个名为 `__init__()` 的特殊方法，就像这样:

```python
def __init__(self):
    self.data = []
```

当一个类定义了 `__init__()` 方法时，类的实例化操作会自动为新创建的类实例发起调用 `__init__()`。 因此在这个示例中，可以通过以下语句获得一个经初始化的新实例:

```python
x = MyClass()
```

当然，`__init__()` 方法还可以有额外参数以实现更高灵活性。在这种情况下，**提供给类实例化运算符的参数将被传递给 `__init__()`**。 例如，:

```sh
>>> class Complex:
...     def __init__(self, realpart, imagpart):
...         self.r = realpart
...         self.i = imagpart
...
>>> x = Complex(3.0, -4.5)
>>> x.r, x.i
(3.0, -4.5)
```

### 2.3、实例对象



--------------------------------------------------------------------------

[英文官方文档](https://docs.python.org/3.8/tutorial/classes.html)

[中文官方文档](https://docs.python.org/zh-cn/3.8/tutorial/classes.html)