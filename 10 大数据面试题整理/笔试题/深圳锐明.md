# 深圳锐明笔试 #

## 静态 ##

	1.被static关键字修饰的方法或者变量不需要依赖于对象来进行访问，只要类被加载了，就可以通过类名去进行访问。

	static方法:
		2.在静态方法中不能访问类的非静态成员变量和非静态成员方法，但是在非静态成员方法中是可以访问静态成员方法/变量的。
		3.是没有this的，因为它不依附于任何对象
		4.为什么main方法必须是static的。因为程序在执行main方法的时候没有创建任何对象，因此只有通过类名来访问。

	构造器是否是static方法：
		从导致类加载的角度来看，那么算static的，因为访问类的static方法或static属性，
		或者调用构造函数会导致类被加载。如果从static的访问限制来看，那么不是static，
		构造函数会把this指针压栈，也就是说需要this对象，所以不是static，因为static和对象无关，只和类有关。

	static变量:
		5.静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化;
		6.非静态变量为对象所拥有，在创建对象的时候初始化，有多个副本，各个对象拥有的副本互不影响。
		7.静态成员变量虽然独立于对象，但是不代表不可以通过对象去访问，所有的静态方法和静态变量都可以通过对象访问（只要访问权限足够）。
		8.static是不允许用来修饰局部变量
		9.static成员变量的初始化顺序按照定义的顺序进行初始化。

	static块：
		10.可以置于类中的任何地方，类中可以有多个static块。
		11.在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次.

	12.通过构造器来生成对象。而在生成对象的时候，必须先初始化父类的成员变量。
	   接着执行父类的构造器，完成了父类的初始化，然后就来初始化自身了。

	https://www.cnblogs.com/dolphin0520/p/3799052.html

## 抽象 ##

	1.抽象定义和格式：
		abstract class A{}

	（1）包含抽象方法的类称为抽象类，但并不意味着抽象类中只能有抽象方法(抽象出共同属性)
	（2）可以拥有成员变量和普通的成员方法
	（3）抽象类通过继承的方式使用，一个子类只能继承一个抽象类（父类），在子类中必须实现抽象类中所有的抽象方法。具体的实现方式如下：
		abstract class B extend A{
			//实现全部抽象方法
		}
	（4）抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。
	（5）抽象类不能用来创建对象(不能实例化)。但抽象类可以包含构造器。抽象类里的构造器并不是用于创建对象，而是让其子类调用这些构造器来完成属于抽象类的初始化操作。
	（6）


	2.接口定义和格式：
   		interface A {
          [public] [static] [final] 变量;  //否则编译错误
          [public] [abstract] 方法;
   		}

	（1）接口通过实现的方式使用，一个类可以实现多个接口，在实现类中，需要将接口中所有的方法均实现。其具体格式如下：
	     class B implement A {
	      //实现所有接口中声明的方法
	     }
	（2）接口中的方法必须都是抽象方法。

	3.抽象类和接口的区别
	（1）语法层面上的区别
			a.成员方法:抽象类可以提供普通的成员方法，而接口中只能存在public abstract 方法；
			b.成员变量:抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；
			c.静态:接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；
			d.一个类只能继承一个抽象类，而一个类却可以实现多个接口。
			e.构造器:接口里不包含构造器，抽象类可以包含构造器。
	（2）设计层面上的区别
			a.抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。
				(抽象类，"is a"关系，抽象出共同的本质特征，单一继承；接口，"like a"关系，个性化特征，多重继承。)
			b.对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口
			  的类都必须进行相应的改动。
	https://www.cnblogs.com/dolphin0520/p/3811437.html#!comments

## 继承 ##

	1.在java中，只允许单继承，也就是说 一个类最多只能显示地继承于一个父类。但是一个类却可以被多个类继承，也就是说一个类可以拥有多个子类。

	2.子类继承父类的成员变量

		当子类继承了某个类之后，便可以使用父类中的成员变量，但是并不是完全继承父类的所有成员变量。具体的原则如下：
			a.能够继承父类的public和protected成员变量；不能够继承父类的private成员变量；
			b.对于父类的包访问权限成员变量，如果子类和父类在同一个包下，则子类能够继承；否则，子类不能够继承；
			c.对于子类可以继承的父类成员变量，如果在子类中出现了同名称的成员变量，则会发生隐藏现象，即子类的成员变量会屏蔽掉父类的同名成员变量。
			  如果要在子类中访问父类中同名成员变量，需要使用super关键字来进行引用。

	3.子类继承父类的方法

		子类也并不是完全继承父类的所有方法。
			a.能够继承父类的public和protected成员方法；不能够继承父类的private成员方法；
			b.对于父类的包访问权限成员方法，如果子类和父类在同一个包下，则子类能够继承；否则，子类不能够继承；
			c.对于子类可以继承的父类成员方法，如果在子类中出现了同名称的成员方法，则称为覆盖，即子类的成员方法会覆盖掉父类的同名成员方法。
			  如果要在子类中访问父类中同名成员方法，需要使用super关键字来进行引用。（覆盖只针对非静态方法）

	4.构造器

		子类是不能够继承父类的构造器，但是要注意的是，如果父类的构造器都是带有参数的，则必须在子类的构造器中显示地
		通过super关键字调用父类的构造器并配以适当的参数列表。如果父类有无参构造器，则在子类的构造器中用super关键字
		调用父类构造器不是必须的，如果没有使用super关键字，系统会自动调用父类的无参构造器。

		父类的构造器调用以及初始化过程一定在子类的前面

	5.super

		super主要有两种用法：
			a.super.成员变量/super.成员方法;  //用来在子类中调用父类的同名成员变量或者方法
			b.super(parameter1,parameter2....) //用在子类的构造器中显示地调用父类的构造器，要注意的是，如果是用在子类构造器中，则必须是子类构造器的第一个语句。

	http://www.cnblogs.com/dolphin0520/p/3803432.html

## 垃圾回收 ##

	https://www.cnblogs.com/dolphin0520/p/3783345.html
	https://www.cnblogs.com/andy-zcx/p/5522836.html

## 异常 ##

## util包 ##

## public、private、protected ##

![](https://i.imgur.com/mtMo88B.png)

## 重写重载的区别，重载的方法能否根据返回类型进行区分？ ##

	方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。

	方法重写(0veriding)：对父类的方法进行重新定义，且子类中的方法与父类中继承的
						方法有完全相同的返回值类型、方法名、参数个数以及参数类型。
						建立在继承关系上；
	方法重载(Overloading)：在一个类中，多个方法的方法名相同，但是参数列表不同。
						  参数列表不同指的是参数个数、参数类型或者参数的顺序不同。
						  **只能通过参数列表，重载的方法的返回值类型可以相同也可以不相同**

	1.如果子类将父类中的方法重写了，调用的时候肯定是调用被重写过的方法，那么如果现在一定要调用父类中的方法，使用super关键就可以实现。
	2.被子类重写的方法不能拥有比父类方法更加严格的访问权限。如果定义父类的方法为public，在子类定义为private，程序运行时就会报错。
	3.当父类中方法的访问权限修饰符为private时，在子类是不能被重写的。
	4.在继承过程中如果父类当中的方法抛出异常，那么在子类中重写父类的该方法时，也要抛出异常，
	  而且抛出的异常不能多于父类中抛出的异常(可以等于父类中抛出的异常)。换句话说，重写方法一定不能抛出新的检查异常，
      或者比被重写方法声明更加宽泛的检查型异常。例如，父类的一个方法申明了一个检查异常IOException，在重写这个方法时就不能抛出Exception，
      只能抛出IOException的子类异常，
	5.如果子类中创建了一个成员变量，而该变量和父类中的一个变量名称相同，称作变量重写或属性覆盖。

	6.构造方法也可以重载。
	7.不能通过访问权限、返回类型、抛出的异常进行重载。
	8.方法的异常类型和数目不会对重载造成影响。
	9.可以有不同的访问修饰符。
	10.可以抛出不同的异常。

## primitive ##

	java中，变量分为两种，
		1.primitive主数据类型，也称之其为基本数据类型
				boolean, char, byte,short,int,long,float,double
		2.引用数据类型
				当一个对象赋值给一个引用变量时，那么，则表明这个引用变量是指向这个对象的；
				一个对象可以有多个引用;一个引用同一时刻，则只能指向一个对象；

## finalize ##

	1.finalize()是Object的protected方法，子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法。
	2.finalize()与C++中的析构函数不是对应的。C++中的析构函数调用的时机是确定的（对象离开作用域或delete掉），
	  但Java中的finalize的调用具有不确定性
	3.不建议用finalize方法完成“非内存资源”的清理工作，但建议用于：
	  (1)清理本地对象(通过JNI创建的对象)；
	  (2)作为确保某些非内存资源(如Socket、文件等)释放的一个补充：在finalize方法中显式调用其他资源释放方法。

## 冒泡排序 ##

## 树的先序遍历 ##

## sleep ##

	1.对于sleep()方法，我们首先要知道该方法是属于Thread类中的。而wait()方法，则是属于Object类中的。
	2.sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。
	在调用sleep()方法的过程中，线程不会释放对象锁。
	3.而当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备
	获取对象锁进入运行状态.

	http://www.cnblogs.com/hongten/p/hongten_java_sleep_wait.html

## 编程题：字符串转整数 ##

	https://blog.csdn.net/ouyangyanlan/article/details/72897779

![](https://i.imgur.com/KlXPHxA.png)

![](https://i.imgur.com/0iwEnG7.png)

![](https://i.imgur.com/ySmfSiq.png)

![](https://i.imgur.com/jZs88V8.png)

![](https://i.imgur.com/BXiInle.png)

![](https://i.imgur.com/4l3Byb7.png)

![](https://i.imgur.com/dJgJvFA.png)

![](https://i.imgur.com/ijJgIki.png)

![](https://i.imgur.com/LiJQSY8.png)

![](https://i.imgur.com/C7axi3l.png)

![](https://i.imgur.com/jgMxKgC.png)

![](https://i.imgur.com/OIa6fGn.png)

![](https://i.imgur.com/UwVq8PB.png)

![](https://i.imgur.com/CbYKk7P.png)

![](https://i.imgur.com/9RNjSyn.png)

	https://wenku.baidu.com/view/06ea25f4caaedd3382c4d306.html
	==================
	https://wenku.baidu.com/view/bc19645276232f60ddccda38376baf1ffc4fe325.html?rec_flag=default&sxts=1537062893458

## 写一个Singleton（单例模式）出来 ##

	public class Singleton{
		private static Singleton instance = null;

		private Singleton(){}

		public static Singleton getInstance(){
			if(instance==null){
				instance = new Singleton();
			}
			return instance;
		}

	}
