# 面向对象04--内部类

## 形式参数类型问题

基本类型

引用类型：

    类:返回的是该类的对象
    抽象类:返回的是该抽象类的子类对象
    接口:返回的是该接口的实现类的对象

```
//类:返回的是该类的对象
class Student {
	public void study() {
		System.out.println("Good Good Study,Day Day Up");
	}
}

class StudentDemo {
	public void method(Student s) { //ss; ss = new Student();  Student s = new Student();
		s.study();
	}
}

class StudentTest {
	public static void main(String[] args) {		
		//需求：我要测试StudentDemo类中的method()方法
		StudentDemo sd = new StudentDemo();
		Student ss = new Student();
		sd.method(ss);
		System.out.println("----------------");

		//匿名对象用法
		new StudentDemo().method(new Student());
	}
}
```
```
//抽象类:返回的是该抽象类的子类对象
abstract class Person {
	public abstract void study();
}

class Student extends Person {
	public void study() {
		System.out.println("Good Good Study,Day Day Up");
	}
}

class PersonTest2 {
	public static void main(String[] args) {
		//需求：我要测试Person类中的study()方法
		PersonDemo pd = new PersonDemo();
		Person p = pd.getPerson(); //new Student();  Person p = new Student(); 多态
		p.study();
	}
}
```
```
//接口:返回的是该接口的实现类的对象
interface Love {
	public abstract void love();
}

//定义具体类实现接口
class Teacher implements Love {
	public void love() {
		System.out.println("老师爱学生,爱Java,爱林青霞");
	}
}

class TeacherTest {
	public static void main(String[] args) {
		//需求：我要测试LoveDemo类中的love()方法
		LoveDemo ld = new LoveDemo();
		Love l = new Teacher();
		ld.method(l);
	}
}
```

## 返回值类型问题

基本类型

引用类型

    类:返回的是该类的对象
    抽象类:返回的是该抽象类的子类对象
    接口:返回的是该接口的实现类的对象

```
//类:返回的是该类的对象
class Student {
	public void study() {
		System.out.println("Good Good Study,Day Day Up");
	}
}

class StudentDemo {
	public Student getStudent() {
		//Student s = new Student();
		//Student ss = s;

		//Student s = new Student();
		//return s;
		return new Student();
	}
}

class StudentTest2 {
	public static void main(String[] args) {
		//需求：我要使用Student类中的study()方法
		//但是，这一次我的要求是，不要直接创建Student的对象
		//让你使用StudentDemo帮你创建对象
		StudentDemo sd = new StudentDemo();
		Student s = sd.getStudent(); //new Student(); Student s = new Student();
		s.study();
	}
}
```
```
//抽象类:返回的是该抽象类的子类对象
abstract class Person {
	public abstract void study();
}

class PersonDemo {
	public Person getPerson() {
		//Person p = new Student();
		//return p;

		return new Student();
	}
}

class Student extends Person {
	public void study() {
		System.out.println("Good Good Study,Day Day Up");
	}
}

class PersonTest2 {
	public static void main(String[] args) {
		//需求：我要测试Person类中的study()方法
		PersonDemo pd = new PersonDemo();
		Person p = pd.getPerson(); //new Student();  Person p = new Student(); 多态
		p.study();
	}
}
```
```
//接口:返回的是该接口的实现类的对象
interface Love {
	public abstract void love();
}

class LoveDemo {
	public Love getLove() {
		//Love l = new Teacher();
		//return l;

		return new Teacher();
	}
}

//定义具体类实现接口
class Teacher implements Love {
	public void love() {
		System.out.println("老师爱学生,爱Java,爱林青霞");
	}
}

class TeacherTest2 {
	public static void main(String[] args) {
		LoveDemo ld = new LoveDemo();
		Love l = ld.getLove(); //new Teacher(); Love l = new Teacher(); 多态
		l.love();
	}
}
```
## 链式编程

每次调用完毕方法后，返回的是一个对象。

```
class Student {
	public void study() {
		System.out.println("Good Good Study,Day Day Up");
	}
}

class StudentDemo {
	public Student getStudent() {
		return new Student();
	}
}

class StudentTest3 {
	public static void main(String[] args) {

		StudentDemo sd = new StudentDemo();
		//Student s = sd.getStudent();
		//s.study();

		sd.getStudent().study();
	}
}
```

## 包

其实就是文件夹

#### 作用

		A:区分同名的类
		B:对类进行分类管理
			a:按照功能分
			b:按照模块分

#### 包的定义

		package 包名;

		多级包用.分开。

#### 注意事项

		A:package语句必须在文件中的第一条有效语句
		B:在一个java文件中，只能有一个package
		C:如果没有package，默认就是无包名

#### 带包的编译和运行

手动式

    a:javac编译当前类文件。
    b:手动建立包对应的文件夹。
    c:把a步骤的class文件放到b步骤的最终文件夹下。
    d:通过java命令执行。注意了：需要带包名称的执行
    java cn.itcast.HelloWorld

自动式

    a:javac编译的时候带上-d即可
    javac -d . HelloWorld.java
    b:通过java命令执行。和手动式一样

#### 导包

	(1)import。
	(2)格式：
		import 包名...类名;
		另一种：
			`import 包名...*;`(不建议)
	(3)package,import,class的顺序
		package > import > class

#### 权限修饰符

限制|public|protected|默认|private
---|:--:|---:|---:|---:
同一类中|√|√|√|√
同一包子类,其他类|√|√|√
不同包子类|√|√		
不同包其他类|√			

这四种权限修饰符在任意时刻只能出现一种。


#### 常见的修饰符

分类

		权限修饰符：private,默认,protected,public
		状态修饰符：static,final
		抽象修饰符：abstract

常见的类及其组成的修饰

		类：
			默认,public,final,abstract

			常用的：public

		成员变量：
			private,默认,protected,public,static,final

			常用的：private

		构造方法：
			private,默认,protected,public

			常用的：public

		成员方法：
			private,默认,protected,public,static,final,abstract

			常用的：public

另外比较常见的：

		public static final int X = 10;
		public static void show() {}
		public final void show() {}
		public abstract void show();

## 内部类

把类定义在另一个类的内部，该类就被称为内部类。
		举例：把类B定义在类A中，类B就被称为内部类。

#### 内部类的访问规则

		A:可以直接访问外部类的成员，包括私有
		B:外部类要想访问内部类成员，必须创建对象
```
class Outer {
	private int num = 10;

	class Inner {
		public void show() {
			System.out.println(num);
		}
	}

	public void method() {
		//找不到符号
		//show();

		Inner i = new Inner();
		i.show();
	}

}

class InnerClassDemo {
	public static void main(String[] args) {

	}
}
```

#### 内部类的分类

		A:成员内部类
		B:局部内部类

##### 成员内部类

    在成员位置定义的类，被称为成员内部类。
    访问：
		外部类名.内部类名 对象名 = 外部类对象.内部类对象;
```
class Outer {
	private int num = 10;

	class Inner {
		public void show() {
			System.out.println(num);
		}
	}
}

class InnerClassDemo3 {
	public static void main(String[] args) {
		//需求：我要访问Inner类的show()方法
		//Inner i = new Inner();
		//i.show();

		//格式：外部类名.内部类名 对象名 = 外部类对象.内部类对象;
		Outer.Inner oi = new Outer().new Inner();
		oi.show();
	}
}
```

成员内部类修饰符

		A:private 为了数据的安全性
		B:static 为了访问的方便性

		成员内部类不是静态的：
			外部类名.内部类名 对象名 = new 外部类名.new 内部类名();
		成员内部类是静态的：
			外部类名.内部类名 对象名 = new 外部类名.内部类名();

```
//为了保证数据的安全性，一般内部类就是不让外界直接访问的，所以需要加private。
    class Body {
      	private class Heart {
      		public void operator() {
      			System.out.println("心脏搭桥");
      		}
      	}

      	public void method() {
      		if(如果你是外科医生) {
      			Heart h = new Heart();
      			h.operator();
      			}
      		}
      	}

    class InnerClassDemo4 {
        public static void main(String[] args) {
			Body b =  new Body();
			b.method();
		}
    }
```
```
/*
* static 为了让数据访问更方便
* 被静态修饰的成员内部类只能访问外部类的静态成员
* 内部类被静态修饰后的方法:
*     静态方法
*     非静态方法
*/
	class Outer {
		private int num = 10;
		private static int num2 = 100;

		//内部类用静态修饰是因为内部类可以看出是外部类的成员
		public static class Inner {
      		public void show() {
      			//System.out.println(num); //报错
      			System.out.println(num2);
      		}

      		public static void show2() {
      			//System.out.println(num);
      			System.out.println(num2);
      		}		
      	}
    }

	class InnerClassDemo4 {
		public static void main(String[] args) {
			//成员内部类被静态修饰后的访问方式是:
      		//格式：外部类名.内部类名 对象名 = new 外部类名.内部类名();
      		Outer.Inner oi = new Outer.Inner();
      		oi.show();
      		oi.show2();

      		//show2()的另一种调用方式
      		Outer.Inner.show2();
      	}
    }
```

成员内部类的面试题(填空)
```
	30,20,10

	class Outer {
		public int num = 10;

		class Inner {
			public int num = 20;

			public viod show() {
				int num  = 30;

				System.out.println(num);
				System.out.println(this.num);
				System.out.println(Outer.this.num);
			}
		}
	}
```

		注意：

			1:内部类和外部类没有继承关系。
			2:通过外部类名限定this对象
						Outer.this

##### 局部内部类

    局部内部类访问局部变量的注意事项?
    		A:局部内部类访问局部变量必须加final修饰。
    		B:为什么呢?
			局部变量是随着方法的调用而调用，随着调用完毕而消失。
			而堆内存的内容并不会立即消失。所以，我们加final修饰。
			加入final修饰后，这个变量就成了常量。既然是常量。你消失了。
			我在内存中存储的是数据20，所以，我还是有数据在使用。
```
class Outer {
	private int num  = 10;

	public void method() {
		//int num2 = 20;
		//final int num2 = 20;
		class Inner {
			public void show() {
				System.out.println(num);
				//从内部类中访问本地变量num2; 需要被声明为最终类型
				System.out.println(num2);//20
			}
		}

		//System.out.println(num2);

		Inner i = new Inner();
		i.show();
	}
}

class InnerClassDemo5 {
	public static void main(String[] args) {
		Outer o = new Outer();
		o.method();
	}
}
```
#### 匿名内部类

		A:是局部内部类的简化形式
		B:前提
			存在一个类或者接口
		C:格式:
			new 类名或者接口名() {
				重写方法;
			}
		D:本质：
			其实是继承该类或者实现接口的子类匿名对象
```
interface Inter {
	public abstract void show();
}

class Outer {
	public void method() {

		new Inter() {
			public void show() {
				System.out.println("show");
			}
		};
	}
}

class InnerClassDemo6 {
	public static void main(String[] args) {
		Outer o = new Outer();
		o.method();
	}
}
```
匿名内部类的方法调用
```
interface Inter {
	public abstract void show();
	public abstract void show2();
}

class Outer {
	public void method() {
		//一个方法的时候
		/*
		new Inter() {
			public void show() {
				System.out.println("show");
			}
		}.show();
		*/
		
		//如果我是很多个方法，就很麻烦了
		Inter i = new Inter() { //多态
			public void show() {
				System.out.println("show");
			}
			
			public void show2() {
				System.out.println("show2");
			}
		};
		
		i.show();
		i.show2();
	}
}

class InnerClassDemo6 {
	public static void main(String[] args) {
		Outer o = new Outer();
		o.method();
	}
}
```

匿名内部类在开发中的使用
```
	我们在开发的时候，会看到抽象类，或者接口作为参数。
	而这个时候，我们知道实际需要的是一个子类对象。
	如果该方法仅仅调用一次，我们就可以使用匿名内部类的格式简化。

	interface Person {
		public abstract void study();
	}

	class PersonDemo {
		public void method(Person p) {
			p.study();
		}
	}

	class PersonTest {
		public static void main(String[] args) {
			PersonDemo pd = new PersonDemo();
			pd.method(new Person() {
				public void study() {
					System.out.println("好好学习，天天向上");
				}
			});
		}
	}
```
匿名内部类的面试题
```
/*
	匿名内部类面试题：
		按照要求，补齐代码
			interface Inter { void show(); }
			class Outer { //补齐代码 }
			class OuterDemo {
				public static void main(String[] args) {
					  Outer.method().show();
				  }
			}
			要求在控制台输出”HelloWorld”
*/

interface Inter { 
	void show(); 
	//public abstract
}

class Outer { 
	//补齐代码
	public static Inter method() {
		//子类对象 -- 子类匿名对象
		return new Inter() {
			public void show() {
				System.out.println("HelloWorld");
			}
		};
	}
}

class OuterDemo {
	public static void main(String[] args) {
		Outer.method().show();
		/*
			1:Outer.method()可以看出method()应该是Outer中的一个静态方法。
			2:Outer.method().show()可以看出method()方法的返回值是一个对象。
				又由于接口Inter中有一个show()方法,所以我认为method()方法的返回值类型是一个接口。
		*/
	}
}
```