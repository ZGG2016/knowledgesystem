# 基础

## 一、Java语言特点

- 简单性		   解释性
- 面向对象		高性能
- 分布式处理	 多线程
- 健壮性		   动态
- 结构中立		安全性
- 开源
- 跨平台

1、什么是跨平台性？

通过Java语言编写的应用程序在不同的系统平台上都可以运行。

原理是：只要在需要运行java应用程序的操作系统上，先安装一个Java虚拟机(JVM Java Virtual Machine)即可。由JVM来负责Java程序在该系统中的运行。

![java01](https://s1.ax1x.com/2020/06/30/NIDOKS.png)

因为有了JVM，所以同一个Java程序在三个不同的操作系统中都可以执行。这样就实现了Java程序的跨平台性。也称为Java具有良好的可移植性。[jvm 不是跨平台的]

    JRE(Java Runtime Environment    Java运行环境)
        包括Java虚拟机(JVM Java Virtual Machine)和Java程序所需的核心类库等，如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。

    JDK(Java Development Kit    Java开发工具包)
        JDK是提供给Java开发人员使用的，其中包含了java的开发工具，也包括了JRE。所以安装了JDK，就不用在单独安装JRE了。
        其中的开发工具：编译工具(javac.exe)  打包工具(jar.exe)等
    简单而言：使用JDK开发完成的java程序，交给JRE去运行。

## 二、下载、安装

## 三、wordcount 实例
```
class HelloWorld
{
	public static void main(String [] args)
	{
		System.out.println(“Hello World”);
	}
}
```
程序解析:

- 首先编写java源代码程序，扩展名.java
- 在命令行模式中，输入javac命令对源代码进行编译，生成字节码文件：`javac HelloWorld.java`
- 编译完成后，如果没有报错信息，输入java命令对class字节码文件进行解释运行：`java HelloWorld`

运行原理图解：

![java02](https://s1.ax1x.com/2020/06/30/NIyG4A.png)

## 三、常见错误

- 文件扩展名隐藏导致编译失败
- class写错	Class claas…
- 类名格式有问题	暂时全部使用英文
- 类名后面的大括号匹配不正确
- main方法格式错误
	public static void main(String [] args){ }
- main方法大括号缺失
- 打印语句拼写错误：System.out.println(“”);
- 引号使用错误，使用成中文全角引号

## 四、环境变量

### 1、path环境变量配置的作用

程序的执行需要使用 **外部指令javac，但是javac指令仅仅能在JDK安装目录下的bin目录下执行**，因此程序只能写入bin目录。而程序开发过程中，不能将源代码写入JDK的安装目录，因此需要将源程序保存到任意位置的指定目录(英文目录)，所以需要使javac指令在任意目录下可以运行。

### 2、classpath环境变量配置方式

配置方式：

    创建新的变量名称：classpath
    值设定为指定的还有class文件的目录，多个目录间使用分号(;)分割

作用：

    使classpath目录中的.class文件可以在任意目录运行

技巧：

    通常将配置的目录最前面添加.配置，即当前目录。使.class文件搜索时首先搜索当前目录，然后根据目录配置的顺序依次查找，找到后即运行，因此classpath目录中的配置存在先后顺序

### 3、path和classpath的区别

**path环境变量里面记录的是可执行性文件**，如.exe文件，对可执行文件先在当前路径去找，如果没找到就去path环境变量中配置的路径去找

**classpath环境变量里记录的是java类的运行文件所在的目录**

## 五、关键字

![java03](https://s1.ax1x.com/2020/06/30/NIcL7D.png)

![java04](https://s1.ax1x.com/2020/06/30/NIcq0O.png)

## 六、标识符

概述

    给类,接口,方法,变量等起名字时使用的字符序列

组成规则

    英文大小写字母
    数字字符
    $和_

注意事项

    不能以数字开头
    不能是Java中的关键字
    区分大小写

## 七、常见的命名规则(见名知意)

	A:包	全部小写
		单级包：小写
			举例：liuyi,com
		多级包：小写，并用.隔开
				举例：cn.itcast,com.baidu				
	B:类或者接口
		一个单词：首字母大写
			举例：Student,Demo
		多个单词：每个单词首字母大写
			举例：HelloWorld,StudentName
	C:方法或者变量
		一个单词：首字母小写
			举例：name,main
		多个单词：从第二个单词开始，每个单词首字母大写
			举例：studentAge,showAllNames()
	D:常量	全部大写
		一个单词：大写
			举例：PI
		多个单词：大写，并用_隔开
			举例：STUDENT_MAX_AGE

## 八、注释

单行和多行注释：被注释的文字，不会被JVM（java虚拟机）解释执行。

文档注释：注释内容可以被JDK提供的工具 javadoc 所解析，生成一套以网页文件形式体现的该程序的说明文档。
```
A:单行注释	//
B:多行注释	/**/
C:文档注释  /** */
```
## 九、常量、进制和进制转换

### 1、常量：在程序执行的过程中其值不可以发生改变。

	Java中常量分类:
		A:字面值常量
		B:自定义常量(面向对象部分讲)

字面值常量类型|说明
--|:--:
字符串常量|用双引号括起来的内容
整数常量|所有整数 12,23
小数常量|所有小数 12.34,56.78
字符常量|用单引号括起来的内容 ‘a’,’A’,’0’
布尔常量|较为特有，只有true和false
空常量|null(数组部分讲解)

### 2、进制：一种进位方法。X进制，就表示某一位置上的数运算时是逢X进一位。

	对整数常量提供了4种表现形式：
		二进制
		八进制
		十进制
		十六进制

![java08](https://s1.ax1x.com/2020/06/30/NILWM8.png)

## 十、原码、反码和补码

在计算机内，有符号数有3种表示法：原码、反码和补码。**所有数据的运算都是采用补码进行的**。

原码

	就是二进制定点表示法，即最高位为符号位，“0”表示正，“1”表示负，其余位表示数值的大小。

反码

	正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。

补码

	正数的补码与其原码相同；负数的补码是在其反码的末位加1。

![java05](https://s1.ax1x.com/2020/06/30/NIoqxg.png)

## 十一、变量

概述

	在程序执行的过程中，在某个范围内其值可以发生改变的量
	理解：如同数学中的未知数

定义格式

	A:数据类型 变量名 = 初始化值;
	B:数据类型 变量名;
		变量名 = 初始化值;
	注意：格式是固定的，记住格式，以不变应万变

## 十二、数据类型和类型转换

Java语言是强类型语言，对于每一种数据都定义了明确的具体数据类型， **在内存总分配了不同大小的内存空间**。

![java06](https://s1.ax1x.com/2020/06/30/NI2S54.png)

**1 byte = 8 bit**

![java07](https://s1.ax1x.com/2020/06/30/NI2dRs.png)

注意：

	A:long  8个字节；float 4个字节
	B:它们底层的存储结构不同。
	C:float表示的数据范围比long的范围要大
			long：2^63-1
			float：3.4*10^38 > 2*10^38 > 2*8^38 = 2*2^3^38 = 2*2^114 > 2^63-1
```
//长整型用L、l标记;浮点数单精度用F、f标记
int i = 100000000000000; //错误，超出了int的范围
long i = 100000000000000L; //正确
long i = 100; //正确
long i = 100L; //正确。最好加L
//浮点数默认double
float i = 12.345; // 错误，double占用8个字节的存储空间，float占用4个字节,double转float截取，可以会损失精度。
double i = 12.345; //正确
```

作用域

    变量定义在哪一级大括号中，哪个大括号的范围就是这个变量的作用域。相同的作用域中不能定义两个同名变量。

初始化值

    没有初始化值不能直接使用
    在一行上建议只定义一个变量；可以定义多个，但是不建议

boolean类型不能转换为其他的数据类型

默认转换

    A:从小到大：同时有byte、int，那么byte先转成int 计算
    B:byte,short,char—int—long—float—double
    C:byte,short,char相互之间不转换，他们参与运算首先转换为int类型

实例：
```
//定义一个byte类型，一个int类型，做加法
byte a = 3;
int b = 4;
System.out.println(a + b);

//byte c =  a + b; //可能损失精度
int c = a + b;
System.out.println(c);
```
**1 byte = 8 bit; 4 byte = 32 bit**

![java09](https://s1.ax1x.com/2020/06/30/NIvWfs.png)

强制转换

	A:从大到小
	B:可能会有精度的损失，一般不建议这样使用。
	C:格式： 目标类型 变量名=(目标类型)(被转换的数据);

实例
```
//这个肯定没有问题
//int c = a + b;

//byte c = 7;
//这个是有问题的
//byte c = a + b;
//用强制类型转换改进
byte c = (byte) (a + b);
System.out.println(c);
```

```
//定义了三个byte类型的变量，b1，b2，b3
//b1的值是3，b2的值是4，b没有值
byte b1 = 3,b2 = 4,b;

//b = b1 + b2; //这个是类型提升，所有有问题

b = 3 + 4; //常量，先把结果计算出来，然后看是否在byte的范围内，如果在就不报错。
```

```
//因为byte的范围是：-128到127。
//而130不在此范围内，所以报错。
//byte b = 130;

//我们可以使用强制类型转换
byte b = (byte) 130;

//结果是多少呢?  -126
System.out.println(b);  

分析过程：
	我们要想知道结果是什么，就应该知道是如何进行计算的。
	而我们又知道计算机中数据的运算都是补码进行的。
	而要得到补码，首先要计算出数据的二进制。

	A:获取130这个数据的二进制。
		00000000 00000000 00000000 10000010
		这是130的原码，也是反码，还是补码。
	B:做截取操作，截成byte类型的了。
		10000010
		这个结果是补码。
	C:已知补码求原码。
		符号位		数值位
	补码：	1			0000010

	反码：	1			0000001

	原码：	1			1111110

====================================================
	byte b1 = 127;
	byte b2 = (byte)128; //-128
	byte b3 = (byte)129; //-127
	byte b4 = (byte)130; //-126

	byte的范围：-128 ~ 127

	128：10000000
	-128：10000000 (这里的1即是符号位，也是数值位)
```

```
// 一个字符和一个整数相加：根据 ascii 码计算，‘a’是97 ，结果为98
System.out.println('a'+1);

//字符串数据和其他数据做+，结果是字符串类型。
//这里的+不是加法运算，而是字符串连接符。
System.out.println("hello"+'a'+1); //helloa1
System.out.println('a'+1+"hello"); //98hello

System.out.println("5+5="+5+5); //5+5=55
System.out.println(5+5+"=5+5"); //10=5+5
```

## 十三、ASCII码表

	'a' = 97  往后依次+1
	'A' = 65  往后依次+1
	'0' = 48  往后依次+1

## 十四、运算符

### 1、算术运算符
```
A:+,-,*,/,%,++,--
B:+的用法
		a:加法
		b:正号
		c:字符串连接符
C:/和%的区别
		数据做除法操作的时候，/取得是商，%取得是余数
D:++和--的用法
		a:他们的作用是自增或者自减
		b:使用
			**单独使用
				放在操作数据的前面和后面效果一样。
				a++或者++a效果一样。
			**参与操作使用
				放在操作数的前面：先自增或者自减，再参与操作
					int a = 10;
					int b = ++a;
				放在操作数的后面：先参与操作，再自增或者自减
					int a = 10;
					int b = a++;
        a=2;b=++a   a=2;b=3
        a=2;b=a++   a=3;b=2
```
### 2、赋值运算符

```
A:=,+=,-=,*=,/=,%=等
B:=叫做赋值运算符，也是最基本的赋值运算符
	int x = 10; 把10赋值给int类型的变量x。
C:扩展的赋值运算符的特点
	隐含了自动强制转换。

	面试题：
			short s = 1;
			s = s + 1;  //错误，会损失精度

			short s = 1;
			s += 1;  //正确，相当于  s = (short) (s + 1);
				请问上面的代码哪个有问题?
```

### 3、比较运算符

	A:==,!=,>,>=,<,<=
	B:无论运算符两端简单还是复杂最终结果是boolean类型。
	C:千万不要把==写成了=
```
int a = 10;
int b = 20;
//boolean flag = (a == b); //正确
boolean flag = (a = b); //这个是有问题的，不兼容的类型。a是int，但赋给了boolean.
System.out.println(flag);

int c = (a = b); //把b赋值给a，然后把a留下来
System.out.println(c); //20
```

### 4、逻辑运算符

	A:&,|,^,!,&&,||
	B:逻辑运算符用于连接boolean类型的式子
	C:结论
		&:有false则false
		|:有true则true
		^:相同则false，不同则true。
		情侣关系。
		!:非true则false，非false则true

		&&:结果和&是一样的，只不过有短路效果。左边是false，右边不执行。
		||:结果和|是一样的，只不过有短路效果。左边是true，右边不执行。

### 5、位运算符

符号|说明
--|:--:
&| 有0则为0
\|	|有1则为1
^	|相同是0；不相同1;异或两次，值不变
~ | 0变1；1变0

```
int a = 3;
int b = 4;

System.out.println(3 & 4);
System.out.println(3 | 4);
System.out.println(3 ^ 4);
System.out.println(~3);

分析：因为是位运算，所以我们必须先把数据换算成二进制。

3的二进制：11
00000000 00000000 00000000 00000011
4的二进制：100
00000000 00000000 00000000 00000100

&位与运算：有0则0。
 00000000 00000000 00000000 00000011
&00000000 00000000 00000000 00000100
-----------------------------------
00000000 00000000 00000000 00000000
结果是：0

|位或运算：有1则1。
 00000000 00000000 00000000 00000011
|00000000 00000000 00000000 00000100
-----------------------------------
00000000 00000000 00000000 00000111
结果是：7

^位异或运算：相同则0，不同则1。
 00000000 00000000 00000000 00000011
&00000000 00000000 00000000 00000100
-----------------------------------
00000000 00000000 00000000 00000111
结果是：7

~按位取反运算符：0变1，1变0
 00000000 00000000 00000000 00000011
~11111111 11111111 11111111 11111100 (补码)

补码：11111111 11111111 11111111 11111100
反码：11111111 11111111 11111111 11111011
原码：10000000 00000000 00000000 00000100
结果是：-4
```
```
int a = 10;
int b = 20;

System.out.println("a:"+a+",b:"+b);

//方式1：使用第三方变量(开发中用的)
/*
int c = a;
a = b;
b = c;
System.out.println("a:"+a+",b:"+b);
System.out.println("------------");
*/

//方式2：用位异或实现(面试用) ;异或两次，值不变
//左边：a,b,a
//右边：a ^ b
/*
a = a ^ b;
b = a ^ b; //a ^ b ^ b = a
a = a ^ b; //a ^ b ^ a = b
System.out.println("a:"+a+",b:"+b);
*/

//方式3：用变量相加的做法
/*
a = a + b; //a=30
b = a - b; //b=10
a = a - b; //a=20
System.out.println("a:"+a+",b:"+b);
*/

//方式4：一句话搞定
b = (a+b) - (a=b); //b=30-20=10,a=20
System.out.println("a:"+a+",b:"+b);
```

符号|说明
--|:--:
<<|空位补0，被移除的高位丢弃。
\>>|	被移位的二进制最高位是0，右移后，空缺位补0；最高位是1，最高位补1。
\>>>|被移位二进制最高位无论是0或者是1，空缺位都用0补。

```
//<< :把<<左边的数据乘以2的移动次幂
System.out.println(3 << 2); //3*2^2 = 3*4 = 12;

//>> :把>>左边的数据除以2的移动次幂
System.out.println(24 >> 2); //24 / 2^2 = 24 / 4 = 6
System.out.println(24 >>> 2);

System.out.println(-24 >> 2);
System.out.println(-24 >>> 2);

分析：
计算出3的二进制：11
00000000 00000000 00000000 00000011
(00)000000 00000000 00000000 0000001100

>>的移动：
计算出24的二进制：11000
原码：10000000 00000000 00000000 00011000
反码：11111111 11111111 11111111 11100111
补码：11111111 11111111 11111111 11101000

11111111 11111111 11111111 11101000
1111111111 11111111 11111111 111010(00) 补码

补码：1111111111 11111111 11111111 111010
反码：1111111111 11111111 11111111 111001
原码：1000000000 00000000 00000000 000110

结果：-6

>>>的移动：
计算出24的二进制：11000
原码：10000000 00000000 00000000 00011000
反码：11111111 11111111 11111111 11100111
补码：11111111 11111111 11111111 11101000

11111111 11111111 11111111 11101000
0011111111 11111111 11111111 111010(00)

结果：1073741818

面试题：
	请用最有效率的方式写出计算2乘以8的结果?  （除法）
      2 * 8
      2 << 3
```

###	6、三目运算符

	(关系表达式)?表达式1：表达式2；
	如果条件为true，运算后的结果是表达式1；
	如果条件为false，运算后的结果是表达式2；
```
//获取两个整数中的最大值
int x = 100;
int y = 200;

int max = (x > y? x: y);
System.out.println("max:"+max);
System.out.println("--------");

//获取三个整数中的最大值
int a = 10;
int b = 30;
int c = 20;

//分两步：
//A:先比较a,b的最大值
//B:拿a,b的最大值在和c进行比较
int temp = ((a > b)? a: b);
//System.out.println(temp);
int max1 = (temp > c? temp: c);
System.out.println("max1:"+max1);

//一步搞定
//int max2 = (a > b)?((a > c)? a: c):((b > c)? b: c);
//这种做法不推荐。
//int max2 = a > b?a > c? a: c:b > c? b: c;
//System.out.println("max2:"+max2);
System.out.println("--------");

//比较两个整数是否相同
int m = 100;
int n = 200;

//boolean flag = (m == n)? true: false; //boolean 本身的结果就是true\false.
boolean flag = (m == n);
System.out.println(flag);
```
