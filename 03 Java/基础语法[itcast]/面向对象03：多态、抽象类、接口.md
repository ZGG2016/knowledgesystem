# 面向对象03--多态、抽象类、接口

## 一、final关键字

由于继承中方法有一个现象：方法重写。所以，父类的功能，就会被子类给覆盖调。有些时候，我们不想让子类去覆盖掉父类的功能，只能让他使用。针对这种情况，Java就提供了一个关键字：final

final:最终的意思。常见的是它可以修饰类，成员变量，成员方法。

### （1）特点：

	A:它修饰的类，不能被继承。
	B:它修饰的成员方法，不能被重写。
	C:它修饰的成员变量，是一个常量。

### （2）面试相关：

局部变量

	a:基本类型 值不能发生改变
	b:引用类型 地址值不能发生改变，但是对象的内容是可以改变的
```
class Student {
	int age = 10;
}

class FinalTest {
	public static void main(String[] args) {
		//局部变量是基本数据类型
		int x = 10;
		x = 100;
		System.out.println(x);  //100
		final int y = 10;
		//无法为最终变量y分配值
		//y = 100;
		System.out.println(y);  //报错
		System.out.println("--------------");

		//局部变量是引用数据类型
		Student s = new Student();
		System.out.println(s.age);  //10
		s.age = 100;
		System.out.println(s.age);  //100
		System.out.println("--------------");

		final Student ss = new Student();
		System.out.println(ss.age); //10
		ss.age = 100;
		System.out.println(ss.age); //100

		//重新分配内存空间
		//无法为最终变量ss分配值
		ss = new Student();  //报错
	}
}
```
### （3）初始化时机

	a:只能初始化一次。
	b:常见的给值
		定义的时候。(推荐) final int num2 = 20;
		构造方法中。
```
class Demo {
	//int num = 10;
	//final int num2 = 20;

	int num;
	final int num2;

	{
		num2 = 10;
	}

	public Demo() {
		num = 100;
		//无法为最终变量num2分配值
		num2 = 200;
	}
}

class FinalTest2 {
	public static void main(String[] args) {
		Demo d = new Demo();
		System.out.println(d.num);
		System.out.println(d.num2);
	}
}
```
## 二、多态

同一个对象在不同时刻体现出来的不同状态。

### 1、多态的前提：

	A:有继承或者实现关系。
	B:有方法重写。
	C:有父类或者父接口引用指向子类对象。
```
class Fu {
	public void show() {
		System.out.println("show Fu");
	}
}

class Zi extends Fu {

	public void show() {
		System.out.println("show Zi");
	}
}

class DuoTaiDemo {
	public static void main(String[] args) {
		//要有父类引用指向子类对象。
		Fu f = new Zi();

	}
}
```
###	2、多态的分类：

	a:具体类多态
		class Fu {}
		class Zi extends Fu {}

		Fu f = new Zi();
	b:抽象类多态
		abstract class Fu {}
		class Zi extends Fu {}

		Fu f = new Zi();
	c:接口多态
		interface Fu {}
		class Zi implements Fu {}

		Fu f = new Zi();

###	3、多态中的成员访问特点

成员变量：编译看左边，运行看左边（编译是否成功看左边，运行的结果看左边）
```
class Fu {
	public int num = 100;
}

class Zi extends Fu {
	public int num = 1000;
	public int num2 = 200;
}

class DuoTaiDemo {
	public static void main(String[] args) {
		//要有父类引用指向子类对象。
		Fu f = new Zi();
		System.out.println(f.num); //100
		//编译报错：找不到符号
		//System.out.println(f.num2);
	}
}
```
构造方法：子类的构造都会默认访问父类构造
```
class Fu {
    public Fu(){
        System.out.println("show Fu");
    }
}
class Zi extends Fu {
    public Zi(){
        System.out.println("show Zi");
    }
}
class DuoTaiDemo {
    public static void main(String[] args) {
            Fu f = new Zi();
        }
    }
//输出：show Fu  show Zi
```
成员方法：编译看左边，运行看右边
```
class Fu {
	public void show() {
		System.out.println("show Fu");
	}
}

class Zi extends Fu {
	public void show() {
		System.out.println("show Zi");
	}
  public void method() {
		System.out.println("method zi");
	}
}

class DuoTaiDemo {
	public static void main(String[] args) {
		Fu f = new Zi();
		f.show(); //show Zi
    //编译报错：找不到符号
		//f.method();
	}
}
```
静态方法：编译看左边，运行看左边
```
class Fu {
	public static void function() {
		System.out.println("function Fu");
	}
}

class Zi extends Fu {
	public static void function() {
		System.out.println("function Zi");
	}
}

class DuoTaiDemo {
	public static void main(String[] args) {
		Fu f = new Zi();
		f.function(); //function Fu
	}
}
```
###	5、多态的好处：

	A:提高代码的维护性(继承体现)
	B:提高代码的扩展性(多态体现)

###	6、多态的弊端：

	父不能使用子的特有功能。

	现象：
		子可以当作父使用，父不能当作子使用。

###	7、多态中的转型

	A:向上转型
		从子到父
	B:向下转型
		从父到子
```
class Fu {
	public void show() {
		System.out.println("show fu");
	}
}

class Zi extends Fu {
	public void show() {
		System.out.println("show zi");
	}

	public void method() {
		System.out.println("method zi");
	}

}

class DuoTaiDemo4 {
	public static void main(String[] args) {
		//测试
		Fu f = new Zi();
		f.show();
		//f.method();

		//1.创建子类对象。(可以，但是很多时候不合理。而且，太占内存了)
		//Zi z = new Zi();
		//z.show();
		//z.method();

		//2.你能够把子的对象赋值给父亲，那么我能不能把父的引用赋值给子的引用呢?
		//如果可以，但是如下
		Zi z = (Zi)f;
		z.show();
		z.method();
	}
}
```
###	8、子装爹的案例帮助大家理解多态
```

class 孔子爹 {
	public int age = 40;
		public void teach() {
			System.out.println("讲解JavaSE");
		}
	}

class 孔子 extends 孔子爹 {
	public int age = 20;
	public void teach() {
		System.out.println("讲解论语");
	}
	public void playGame() {
		System.out.println("英雄联盟");
	}
}

	//Java培训特别火,很多人来请孔子爹去讲课，这一天孔子爹被请走了
	//但是还有人来请，就剩孔子在家，价格还挺高。孔子一想，我是不是可以考虑去呢?
	//然后就穿上爹的衣服，带上爹的眼睛，粘上爹的胡子。就开始装爹
	//向上转型
	孔子爹 k爹 = new 孔子();
	//到人家那里去了
	System.out.println(k爹.age); //40
	k爹.teach(); //讲解论语
	//k爹.playGame(); //这是儿子才能做的


	//讲完了，下班回家了
	//脱下爹的装备，换上自己的装备
	//向下转型
	孔子 k = (孔子) k爹;
	System.out.println(k.age); //20
	k.teach(); //讲解论语
	k.playGame(); //英雄联盟
```
###	9、图解

![java25](https://s1.ax1x.com/2020/07/04/Nx1p5j.png)

![java26](https://s1.ax1x.com/2020/07/04/Nx1CPs.png)

###	10、示例
```
/*
	看程序写结果:先判断有没有问题，如果没有，写出结果

	多态的成员访问特点：
		方法：编译看左边，运行看右边。

	继承的时候：
		子类中有和父类中一样的方法，叫重写。
		子类中没有父亲中出现过的方法，方法就被继承过来了。
*/
class A {
	public void show() {
		show2();
	}
	public void show2() {
		System.out.println("我");
	}
}
class B extends A {
	/*
	public void show() {
		show2();
	}
	*/

	public void show2() {
		System.out.println("爱");
	}
}
class C extends B {
	public void show() {
		super.show();
	}
	public void show2() {
		System.out.println("你");
	}
}
public class DuoTaiTest4 {
	public static void main(String[] args) {
		A a = new B();
		a.show();  //爱

		B b = new C();
		b.show();  //你
	}
}
```

## 三、抽象类

把多个共性的东西提取到一个类中，这是继承的做法。但是呢，这多个共性的东西，在有些时候，方法声明一样，但是方法体不一定一样。也就是说， **方法声明一样，但是每个具体的对象在具体实现的时候内容不一样** 。所以，我们在定义这些共性的方法的时候，就不能给出具体的方法体。而一个没有具体的方法体的方法是抽象的方法。在一个类中如果有抽象方法，该类必须定义为抽象类。

###	1、抽象类的特点

	A:抽象类和抽象方法必须用关键字abstract修饰
	B:抽象类中不一定有抽象方法，但是有抽象方法的类必须定义为抽象类。
	C:抽象类不能实例化
		因为它不是具体的。
		抽象类有构造方法，但是不能实例化?构造方法的作用是什么呢?
		用于子类访问父类数据的初始化
	D:抽象的子类
		a:如果不想重写抽象方法，该子类是一个抽象类。
		b:重写所有的抽象方法，这个时候子类是一个具体的类。

	抽象类的实例化其实是靠具体的子类实现的。是多态的方式。
		Animal a = new Cat();
```
//abstract class Animal //抽象类的声明格式
abstract class Animal {
	//抽象方法
	//public abstract void eat(){} //空方法体,这个会报错。抽象方法不能有主体
	public abstract void eat();

	public Animal(){}
}

//子类是抽象类
abstract class Dog extends Animal {}

//子类是具体类，重写抽象方法
class Cat extends Animal {
	public void eat() {
		System.out.println("猫吃鱼");
	}
}

class AbstractDemo {
	public static void main(String[] args) {
		//创建对象
		//Animal是抽象的; 无法实例化
		//Animal a = new Animal();
		//通过多态的方式
		Animal a = new Cat();
		a.eat();
	}
}
```
###	2、抽象类的成员特点

    成员变量：既可以是变量，也可以是常量。
    构造方法：有。用于子类访问父类数据的初始化。
    成员方法：既可以是抽象的，也可以是非抽象的。

    抽象类的成员方法特性：
    A:抽象方法 强制要求子类做的事情。
    B:非抽象方法 子类继承的事情，提高代码复用性。
```
abstract class Animal {
	public int num = 10;  //变量
	public final int num2 = 20; //常量

	public Animal() {}

	public Animal(String name,int age){}

	public abstract void show();

	public void method() {
		System.out.println("method");
	}
}

class Dog extends Animal {
	public void show() {
		System.out.println("show Dog");
	}
}

class AbstractDemo2 {
	public static void main(String[] args) {
		//创建对象
		Animal a = new Dog();
		a.num = 100;
		System.out.println(a.num);
		//a.num2 = 200;
		System.out.println(a.num2);
		System.out.println("--------------");
		a.show();
		a.method();
	}
}
```
###	3、示例
```
/*
	猫狗案例
		具体事物：猫，狗
		共性：姓名，年龄，吃饭

	分析：从具体到抽象
		猫:
			成员变量：姓名，年龄
			构造方法：无参，带参
			成员方法：吃饭(猫吃鱼)

		狗:
			成员变量：姓名，年龄
			构造方法：无参，带参
			成员方法：吃饭(狗吃肉)

		因为有共性的内容，所以就提取了一个父类。动物。
		但是又由于吃饭的内容不一样，所以吃饭的方法是抽象的，
		而方法是抽象的类，类就必须定义为抽象类。

		抽象动物类：
			成员变量：姓名，年龄
			构造方法：无参，带参
			成员方法：吃饭();

	实现：从抽象到具体
		动物类:
			成员变量：姓名，年龄
			构造方法：无参，带参
			成员方法：吃饭();

		狗类：
			继承自动物类
			重写吃饭();

		猫类：
			继承自动物类
			重写吃饭();
*/
//定义抽象的动物类
abstract class Animal {
	//姓名
	private String name;
	//年龄
	private int age;

	public Animal() {}

	public Animal(String name,int age) {
		this.name = name;
		this.age = age;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}

	//定义一个抽象方法
	public abstract void eat();
}

//定义具体的狗类
class Dog extends Animal {
	public Dog() {}

	public Dog(String name,int age) {
		super(name,age);
	}

	public void eat() {
		System.out.println("狗吃肉");
	}
}

//定义具体的猫类
class Cat extends Animal {
	public Cat() {}

	public Cat(String name,int age) {
		super(name,age);
	}

	public void eat() {
		System.out.println("猫吃鱼");
	}
}

//测试类
class AbstractTest {
	public static void main(String[] args) {
		//测试狗类
		//具体类用法
		//方式1：
		Dog d = new Dog();
		d.setName("旺财");
		d.setAge(3);
		System.out.println(d.getName()+"---"+d.getAge());
		d.eat();
		//方式2：
		Dog d2 = new Dog("旺财",3);
		System.out.println(d2.getName()+"---"+d2.getAge());
		d2.eat();
		System.out.println("---------------------------");

		Animal a = new Dog();
		a.setName("旺财");
		a.setAge(3);
		System.out.println(a.getName()+"---"+a.getAge());
		a.eat();

		Animal a2 = new Dog("旺财",3);
		System.out.println(a2.getName()+"---"+a2.getAge());
		a2.eat();

		//练习：测试猫类
	}
}
```
###	4、抽象类的几个小问题

	A:抽象类有构造方法，不能实例化，那么构造方法有什么用?
		用于子类访问父类数据的初始化
	B:一个类如果没有抽象方法，却定义为了抽象类，有什么用?
		为了不让创建对象
	C:abstract不能和哪些关键字共存
		a:final	报错:非法的修饰组合
		b:private 报错:非法的修饰组合（抽象方法要被子类重写的。）
		c:static 报错:非法的修饰组合（抽象方法没有方法体，用类名调用没意义。）

## 四、接口

回顾猫狗案例，它们仅仅提供一些基本功能。但是一些功能，比如：猫钻火圈，狗跳高等，不是动物本身就具备的，这些额外的功能定义到动物类中就不合适。所以java中就提供了接口来定义这些额外功能，并不给出具体实现，将来哪些猫狗需要被培训，只需要这部分猫狗把这些额外功能实现即可。

###	1、接口的特点

	A:接口用关键字interface修饰
		interface 接口名 {}
	B:类实现接口用implements修饰
		class 类名 implements 接口名 {}
	C:接口不能实例化：按照多态的方式实例化。
	D:接口的实现类
		a:可以是抽象类。但是意义不大。
		b:可以是具体类。要重写接口中的所有抽象方法。(推荐方案)

	由此可见：
		A:具体类多态(几乎没有)
		B:抽象类多态(常用)
		C:接口多态(最常用)
```
//定义动物培训接口
interface AnimalTrain {
	public abstract void jump();
}

//抽象类实现接口
abstract class Dog implements AnimalTrain {
}

//具体类实现接口
class Cat implements AnimalTrain {
	public void jump() {
		System.out.println("猫可以跳高了");
	}
}

class InterfaceDemo {
	public static void main(String[] args) {
		//AnimalTrain是抽象的; 无法实例化
		//AnimalTrain at = new AnimalTrain();
		//at.jump();

		AnimalTrain at = new Cat();
		at.jump();
	}
}
```
###	2、接口的成员特点

#### （1）成员变量

	只能是常量，并且是静态的。
	默认修饰符：public static final
```
interface Inter {
	public int num = 10;
	public final int num2 = 20;
}

//接口名+Impl这种格式是接口的实现类格式
class InterImpl implements Inter {}

//测试类
class InterfaceDemo2 {
	public static void main(String[] args) {
		//创建对象
		Inter i = new InterImpl();
		System.out.println(i.num);
		System.out.println(i.num2);
		//i.num = 100;
		//i.num2 = 200;
		//System.out.println(i.num); //无法为最终变量num分配值
		//System.out.println(i.num2);//无法无法为最终变量num分配值

}
```      
#### （2）构造方法

	没有构造方法
```
interface Inter {

	//错误: 需要<标识符>
	//public Inter() {}
}


class InterImpl implements Inter {
	public InterImpl() {
		super();  //继承至Object
}

//测试类
class InterfaceDemo2 {
	public static void main(String[] args) {
		//创建对象
		Inter i = new InterImpl();
	}
}
```      
#### （3）成员方法

	只能是抽象的
	默认修饰符：public abstract
```
interface Inter {

	//接口方法不能带有主体
	//public void show() {}

	//abstract void show(); //默认public
	public void show(); //默认abstract
}

class InterImpl extends Object implements Inter {
	public InterImpl() {
		super();
	}

	public void show() {}
}

//测试类
class InterfaceDemo2 {
	public static void main(String[] args) {
		//创建对象
		Inter i = new InterImpl();
	}
}
```
###	3、类与类,类与接口,接口与接口

		A:类与类
			继承关系，只能单继承，可以多层继承
		B:类与接口
			实现关系，可以单实现，也可以多实现。
			还可以在继承一个类的同时，实现多个接口
		C:接口与接口
			继承关系，可以单继承，也可以多继承

###	4、抽象类和接口的区别

		A:成员区别
			抽象类：
          成员变量：既可以是变量，也可以是常量。
          构造方法：有。用于子类访问父类数据的初始化。
          成员方法：既可以是抽象的，也可以是非抽象的。
			接口：
          成员变量：只能是常量，并且是静态的
          构造方法：没有构造方法
          成员方法：抽象的
		B:关系区别:
			类与类：继承关系，只能单继承，可以多层继承
			类与接口：实现关系，可以单实现，也可以多实现。还可以在继承一个类的同时，实现多个接口
			接口与接口：继承关系，可以单继承，也可以多继承
		C:设计理念不同
			抽象类：is a，抽象类中定义的是共性功能。
			接口：like a，接口中定义的是扩展功能。
###	5、示例
```
/*
	猫狗案例,加入跳高的额外功能

	分析：从具体到抽象
		猫：
			姓名,年龄
			吃饭，睡觉
		狗：
			姓名,年龄
			吃饭，睡觉

		由于有共性功能，所以，我们抽取出一个父类：
		动物：
			姓名,年龄
			吃饭();
			睡觉(){}

		猫：继承自动物
		狗：继承自动物

		跳高的额外功能是一个新的扩展功能，所以我们要定义一个接口
		接口：
			跳高

		部分猫：实现跳高
		部分狗：实现跳高
	实现；
		从抽象到具体

	使用：
		使用具体类
*/
//定义跳高接口
interface Jumpping {
	//跳高功能
	public abstract void jump();
}

//定义抽象类
abstract class Animal {
	//姓名
	private String name;
	//年龄
	private int age;

	public Animal() {}

	public Animal(String name,int age) {
		this.name = name;
		this.age = age;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}

	//吃饭();
	public abstract void eat();

	//睡觉(){}
	public void sleep() {
		System.out.println("睡觉觉了");
	}
}

//具体猫类
class Cat extends Animal {
	public Cat(){}

	public Cat(String name,int age) {
		super(name,age);
	}

	public void eat() {
		System.out.println("猫吃鱼");
	}
}

//具体狗类
class Dog extends Animal {
	public Dog(){}

	public Dog(String name,int age) {
		super(name,age);
	}

	public void eat() {
		System.out.println("狗吃肉");
	}
}

//有跳高功能的猫
class JumpCat extends Cat implements Jumpping {
	public JumpCat() {}

	public JumpCat(String name,int age) {
		super(name,age);
	}

	public void jump() {
		System.out.println("跳高猫");
	}
}

//有跳高功能的狗
class JumpDog extends Dog implements Jumpping {
	public JumpDog() {}

	public JumpDog(String name,int age) {
		super(name,age);
	}

	public void jump() {
		System.out.println("跳高狗");
	}
}

class InterfaceTest {
	public static void main(String[] args) {
		//定义跳高猫并测试
		JumpCat jc = new JumpCat();
		jc.setName("哆啦A梦");
		jc.setAge(3);
		System.out.println(jc.getName()+"---"+jc.getAge());
		jc.eat();
		jc.sleep();
		jc.jump();
		System.out.println("-----------------");

		JumpCat jc2 = new JumpCat("加菲猫",2);
		System.out.println(jc2.getName()+"---"+jc2.getAge());
		jc2.eat();
		jc2.sleep();
		jc2.jump();

	}
}
```
