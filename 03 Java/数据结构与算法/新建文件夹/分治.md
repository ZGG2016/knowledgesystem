# 分治

分治算法主要是三点：

- 将一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题----“分”

- 将最后子问题可以简单的直接求解----“治”

- 将所有子问题的解合并起来就是原问题打得解----“合”

# 分治法的特征

分治法所能解决的问题一般具有以下几个特征：

	1) 该问题的规模缩小到一定的程度就可以容易地解决
	
	2) 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。
	
	3) 利用该问题分解出的子问题的解可以合并为该问题的解；
	
	4) 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。

第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；

第二条特征是应用分治法的前提它也是大多数问题可以满足的，此特征反映了递归思想的应用；、

第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法。

第四条特征涉及到分治法的效率，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好。

## 怎么正确使用分治法?

在问题规模与计算量成正比的算法中，分治算法不是最好的解法，并且有可能是效率极其底下的算法。如果存在某个问题，线性增长的问题规模可能带动计算量的非线性增长，并且符合分治算法的三个特征，那么分治算法是一个很不错的选择。

## 例子

二分查找：

[https://github.com/ZGG2016/Algorithm/blob/master/src/search/BinarySearch.java](https://github.com/ZGG2016/Algorithm/blob/master/src/search/BinarySearch.java)

棋盘覆盖：

[https://github.com/ZGG2016/Algorithm/blob/master/src/someExample/ChessBoard.java](https://github.com/ZGG2016/Algorithm/blob/master/src/someExample/ChessBoard.java)

归并排序：

[https://github.com/ZGG2016/Algorithm/blob/master/src/someExample/sort/MergeBU.java](https://github.com/ZGG2016/Algorithm/blob/master/src/someExample/sort/MergeBU.java)

快速排序：

[https://github.com/ZGG2016/Algorithm/blob/master/src/someExample/sort/QuickSort.java](https://github.com/ZGG2016/Algorithm/blob/master/src/someExample/sort/QuickSort.java)

最大子段和：

[https://github.com/ZGG2016/Algorithm/blob/master/src/LeetCode/Divide_and_Conquer/Example.BaiCiZhan.test1.java](https://github.com/ZGG2016/Algorithm/blob/master/src/LeetCode/Divide_and_Conquer/Example.BaiCiZhan.test1.java)

大数乘法：

[https://github.com/ZGG2016/Algorithm/blob/master/src/Example/BigMultiply.java](https://github.com/ZGG2016/Algorithm/blob/master/src/Example/BigMultiply.java)

求数列中最大最小值：

[https://github.com/ZGG2016/Algorithm/blob/master/src/Example/MinMax.java](https://github.com/ZGG2016/Algorithm/blob/master/src/Example/MinMax.java)