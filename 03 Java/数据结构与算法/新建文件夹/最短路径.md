最短路径：

1，在一幅加权有向图中，从顶点s到顶点t的最短路径是所有从s到t的路径中的权重最小者。

2，给定一幅加权有向图和一个顶点s,以s为起点的一棵最短路径树是图的一幅子图，它包含s
   和从s可达的所有顶点。这棵有向树的根节点为s,树的每条路径都是有向图中的一条最短路径。
           
3， distTo[v]:从s到v的已知最短路径的长度
    edgeTo[v]:树中连接v和它的父节点的边
            
4，边的松弛技术：
     放松边v->w意味着检查从s到w的最短路径时候是先从s到v，然后再由v到w。
     如果是，则根据这个情况更新数据结构的内容。
     如果由v到w的最短路径是dist[v]和e.weight*()之和，且这个值不小于distTo[w],
     则这条边失效，并将它忽略。
     
            private void relax(DirectedEdge e){
				int v=e.from(),w=e.to();
				if (distTo[w]>distTo[v]+e.weight()){
					distTo[w]=distTo[v]+e.weight();
					edgeTo[w]=e;
					}
				}
				
5,点的松弛技术：

		    private void relax(EdgeWeightedDigraph G,int v){
				for(DirectedEdge e:G.adj(v)){
					int w=e.to();
					if (distTo[w]>distTo[v]+e.weight()){
						distTo[w]=distTo[v]+e.weight();
						edgeTo[w]=e;
					}
				}
			}		 