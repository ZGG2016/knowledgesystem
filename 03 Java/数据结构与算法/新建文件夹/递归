
6.不懂：在小游戏示例中，为什么{已经过上一步方向和当前方向相同, 则递归搜索时step不变, 否则step+1}

https://blog.csdn.net/sinat_38052999/article/details/73303111
https://www.cnblogs.com/klguang/p/5463137.html
=====================================================================

=====================================================================
杨辉三角:获取杨辉三角指定行、列(从0开始)的值
public int f(int x,int y){
    if(y<=x && y>0){
        if(y==x || y==1) return 1;
        else return f(x-1,y-1)+f(x-1,y);
    }
    return -1;
}
=====================================================================
回文字符串的判断
回文字符串就是正读倒读都一样的字符串。如”98789”, “abccba”都是回文字符串 
public boolean f(String s){
     int b = 0,en = s.length()-1;
     if(b<en){
         if(s.charAt(b)!=s.charAt(en)) return false;
         else return f(s.subString(b+1),subString(0,en-1));
     }
     return true;
}
循环判断：
public boolean f(String s){
     int b = 0,en = s.length()-1;
     while(b<en){
          if(s.charAt(b)!=s.charAt(en)) return false;
          else{
             b++;
             en--;
          }
     }
     return true;
}
=====================================================================
字符串全排列???
=====================================================================
二分查找
public int f(int[] arr,int b,int en,int n){
    if(b<=en){
       int mid = b+(en-b)/2;
       if(arr[mid]==n) return mid;
       else if(arr[mid]>n) return f(arr,b,mid-1,n);
       else if(arr[mid]<n) return f(arr,mid+1,en,n);
    }
    return -1;
}
循环实现：
public int f(int[] arr,int b,int en,int n){
    while(b<=en){
        int mid = b+(en-b)/2;
        if(arr[mid]==n) return mid;
        else if(arr[mid]>n)  en = mid-1;
        else if(arr[mid]<n)  b = mid+1;
    }
    return -1;    
}
=====================================================================
汉诺塔  A(源)、B(中转)、C(目的)
当只有一个盘子的时候，直接就是A->C，这也是递归结束的条件
当有两个盘子的时候，A->B, A->C, B->C。
当有三个或三个以上的盘子的时候，我们这样来考虑把最下面的盘子当做一块，其他盘子当做一块，那么，就简化成了上一步。
           A柱子是源，B柱子是当做临时转换用的源，C是目的。
 当经过上一步后，除了最下面的盘子其他的已经到了B柱子上了，这个时候，A柱子就是当做临时转换用的了，B柱子是源，C是目的。
 所以当n不等于1的时候，会回调两次函数，第一次参数的顺序是n,a,c,b。第二次是n,b,a,c
 递归：
 public static void moveDish(int level, char from, char inter, char to) {
        if (level == 1) { 
            System.out.println("从" + from + " 移动盘子" + level + " 号到" + to);
        } else {          
            moveDish(level - 1, from, to, inter);            
            System.out.println("从" + from + " 移动盘子" + level + " 号到" + to); 
            moveDish(level - 1, inter, from, to); 
        }
}
非递归：https://www.cnblogs.com/sun1993/p/7811492.html
=====================================================================






