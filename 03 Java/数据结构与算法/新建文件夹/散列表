散列表：
   1，散列表的查找：（1）用散列函数将被查找的键转化为数组的一个索引
                    （2）处理碰撞冲突（多个键散列到相同的索引值）
   2，散列函数：
               每种类型的键需要一个与之对应的散列函数。
      将整数散列：除留余数法：
                      用任意正整数k除以大小为素数M的数组，求得余数。
      将浮点数散列：
                  如果键是0-1间的实数，将它乘以M并四舍五入到0到M-1间的索引值。
              更好的方法：将键表示为二进制数，再使用除留余数法
      将字符串散列：把字符串当做一个N位的R进制值，对其除以M取余
                   int hash=0;
                   for(int i=0;i<s.length();i++){
                   		hash=(R*hash+s.charAt(i))%M;
                   }
      三个条件：
              一致性：等价的键必然产生相等的散列值；
              高效性：
              均匀性：均匀的散列所有的键
              
     3，处理碰撞：
            基于拉链法的散列表：
                将大小为M的数组中的每个元素指向一条链表，
                链表中的每个结点都存储了散列值为该元素的索引的键值对
            基于线性探测法的散列表：
                当一个键的散列值已经被另一个不同的键占用，直接检查散列表中的下一个位置（索引值加1）
                
                
 白名单：文件中的键被定义为好键，用例可以选择将所有不在白名单上的键传递到标准输出并
         忽略所有白名单上的键。
 黑名单：文件中的键被定义为坏键，